{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo (a) documenta\u00e7\u00e3o do FastQueue","text":""},{"location":"#fastapi-celery-rabbitmq-processamento-assincrono-de-apis-externas","title":"FastAPI + Celery + RabbitMQ: Processamento Ass\u00edncrono de APIs Externas","text":"<p>Este projeto demonstra como utilizar FastAPI e Celery com RabbitMQ para realizar chamadas ass\u00edncronas a APIs externas, lidando com falhas como timeout e autentica\u00e7\u00e3o.</p>"},{"location":"#tecnologias-utilizadas","title":"\ud83d\udccc Tecnologias Utilizadas","text":"<ul> <li>FastAPI \u2192 Framework para criar a API.</li> <li>Celery \u2192 Gerenciamento de tarefas ass\u00edncronas.</li> <li>RabbitMQ \u2192 Broker de mensagens.</li> <li>Flower \u2192 Monitoramento das tarefas Celery.</li> <li>Requests \u2192 Biblioteca para chamadas HTTP.</li> </ul>"},{"location":"#como-rodar-o-projeto","title":"\ud83d\ude80 Como Rodar o Projeto","text":""},{"location":"#1-instalar-dependencias","title":"1\ufe0f\u20e3 Instalar Depend\u00eancias","text":"<pre><code>pip install fastapi celery[redis] uvicorn requests flower\n</code></pre>"},{"location":"#2-iniciar-o-rabbitmq","title":"2\ufe0f\u20e3 Iniciar o RabbitMQ","text":"<pre><code>docker run -d --hostname rmq-broker --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management\n</code></pre> <ul> <li>Acessar o painel RabbitMQ em: http://localhost:15672</li> <li>Usu\u00e1rio/Senha padr\u00e3o: guest/guest</li> </ul>"},{"location":"#3-iniciar-o-celery-worker","title":"3\ufe0f\u20e3 Iniciar o Celery Worker","text":"<pre><code>celery -A celery_worker.celery_app worker --loglevel=info\n</code></pre>"},{"location":"#4-rodar-fastapi","title":"4\ufe0f\u20e3 Rodar FastAPI","text":"<pre><code>fastapi dev\n</code></pre>"},{"location":"#monitoramento-com-flower","title":"Monitoramento com Flower","text":"<p>O Flower permite visualizar e monitorar as tarefas do Celery em tempo real. </p>"},{"location":"#1-iniciar-o-flower","title":"1\ufe0f\u20e3 Iniciar o Flower","text":"<pre><code>celery -A celery_worker.celery_app flower --port=5555\n</code></pre>"},{"location":"#2-acessar-o-painel-do-flower","title":"2\ufe0f\u20e3 Acessar o Painel do Flower","text":"<ul> <li>Acessar http://localhost:5555 para visualizar as tarefas em tempo real.</li> <li>L\u00e1 voc\u00ea pode ver: \u2705 Tarefas pendentes, em execu\u00e7\u00e3o e finalizadas. \u2705 Tempo de execu\u00e7\u00e3o e falhas. \u2705 Tentativas de reexecu\u00e7\u00e3o por timeout ou erro.</li> </ul>"},{"location":"#testando-a-api","title":"Testando a API","text":"<ul> <li>Enviar uma requisi\u00e7\u00e3o para a API externa</li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8000/request/' -H 'Content-Type: application/json' -d '{\"url\": \"https://jsonplaceholder.typicode.com/todos/1\", \"token\": \"meu_token\"}'\n</code></pre> <ul> <li>Resposta esperada:</li> </ul> <pre><code>{\n    \"task_id\": \"b95b9e8f-2f27-49b1-97b5-34aef06b745d\",\n    \"status\": \"PENDING\"\n}\n</code></pre>"},{"location":"#consultar-o-status-da-tarefa","title":"Consultar o Status da Tarefa","text":"<pre><code>curl -X 'GET' 'http://127.0.0.1:8000/status/b95b9e8f-2f27-49b1-97b5-34aef06b745d'\n</code></pre> <ul> <li>Resposta enquanto est\u00e1 processando:</li> </ul> <pre><code>{\n    \"task_id\": \"b95b9e8f-2f27-49b1-97b5-34aef06b745d\",\n    \"status\": \"PENDING\",\n    \"result\": null\n}\n</code></pre> <ul> <li>Resposta ap\u00f3s concluir:</li> </ul> <pre><code>{\n    \"task_id\": \"b95b9e8f-2f27-49b1-97b5-34aef06b745d\",\n    \"status\": \"SUCCESS\",\n    \"result\": {\n        \"userId\": 1,\n        \"id\": 1,\n        \"title\": \"delectus aut autem\",\n        \"completed\": false\n    }\n}\n</code></pre>"},{"location":"#como-funciona","title":"Como funciona?","text":"<pre><code>1 - O FastAPI recebe uma requisi\u00e7\u00e3o para acessar uma API externa.\n2 - A requisi\u00e7\u00e3o \u00e9 enviada para a fila do RabbitMQ usando Celery.\n3 - O Worker Celery recupera a tarefa e faz a requisi\u00e7\u00e3o \u00e0 API externa.\n4 - Se houver timeout ou erro, o Celery tenta novamente automaticamente.\n5 - O usu\u00e1rio pode consultar o status da tarefa via API.\n</code></pre>"},{"location":"api/","title":"API","text":"<p>Requisi\u00e7\u00e3o de envio e recebimento de dados de API externa.</p> <p>API desenvolvida com FastAPI para gerenciar requisi\u00e7\u00f5es ass\u00edncronas utilizando Celery.</p> Rotas dispon\u00edveis <ul> <li>'POST /request/' -&gt; Enfileira uma nova requisi\u00e7\u00e3o para a API externa.</li> <li>'GET' /status/{task_id}' -&gt; Retorna o status da tarefa enfileirada.</li> </ul>"},{"location":"api/#src.main.get_task_status","title":"<code>get_task_status(task_id)</code>","text":"<p>Retorna o status da tarefa enfileirada.</p> <p>Parameters:</p> Name Type Description Default <code>task_id(str)</code> <p>ID da tarefa Celery.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Status da tarefa e resultado, se dispon\u00edvel.</p> Source code in <code>src/main.py</code> <pre><code>@app.get(\"/status/{task_id}\")\ndef get_task_status(task_id: str):\n    \"\"\"\n    Retorna o status da tarefa enfileirada.\n\n    Args:\n        task_id(str): ID da tarefa Celery.\n\n    Returns:\n        dict: Status da tarefa e resultado, se dispon\u00edvel.\n    \"\"\"\n\n    task_result = fetch_data.AsyncResult(task_id)\n    return {\n        \"task_id\": task_id,\n        \"status\": task_result.status,\n        \"result\": task_result.result if task_result.ready() else None,\n    }\n</code></pre>"},{"location":"api/#src.main.send_request","title":"<code>send_request(url, token)</code>","text":"<p>Enfileira uma requisi\u00e7\u00e3o para uma API externa.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL da API externa a ser acessada.</p> required <code>token</code> <code>str</code> <p>Token de autentica\u00e7\u00e3o (Bearer Token).</p> required <code>Returns</code> <p>dict: ID da tarefa Celery e status inicial.</p> required Source code in <code>src/main.py</code> <pre><code>@app.post(\"/request/\")\ndef send_request(url: str, token: str):\n    \"\"\"\n    Enfileira uma requisi\u00e7\u00e3o para uma API externa.\n\n    Args:\n        url (str): URL da API externa a ser acessada.\n        token (str): Token de autentica\u00e7\u00e3o (Bearer Token).\n\n        Returns:\n            dict: ID da tarefa Celery e status inicial.\n    \"\"\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    task = fetch_data.apply_async(args=[url], kwargs={\"headers\": headers})\n    return {\"task_id\": task.id, \"status\": task.status}\n</code></pre>"},{"location":"api/#endpoints","title":"Endpoints","text":"<p>-<code>POST /request/</code> - Enfileira uma requisi\u00e7\u00e3o para uma API externa. -<code>GET /status/{task_id}</code> - Obt\u00eam o status da tarefa na fila</p>"},{"location":"celery/","title":"Celery","text":"<p>Distribui\u00e7\u00e3o de tarefas em fila para requisi\u00e7\u00e3o em API externa</p> <p>M\u00f3dulo respons\u00e1vel pelo processamento ass\u00edncrono de tarefas utilizando Celery.</p> <ul> <li>O Celery \u00e9 configurado para utilizar o RabbitMQ como broker.</li> <li>A fun\u00e7\u00e3o 'fetch_data' realiza uma requisi\u00e7\u00e3o HTTP ass\u00edncrona.</li> <li>Implementa tratamento de erros para timeout e autentica\u00e7\u00e3o.</li> </ul>"},{"location":"celery/#src.celery_worker.fetch_data","title":"<code>fetch_data(self, url, headers=None)</code>","text":"<p>Realiza uma requisi\u00e7\u00e3o GET para uma API externa, com toler\u00e2ncia a falhas.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL da API externa.</p> required <code>headers</code> <code>(dict, opcional)</code> <p>Dicion\u00e1rio com cabe\u00e7alhos HTTP, incluindo autentica\u00e7\u00e3o.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Resposta JSON da API externa ou mensagem de erro.</p> Tratamento de Erros <ul> <li>Timeout -&gt; Reexecuta a tarefa automaticamente at\u00e9 3 vezes.</li> <li>HTTP 401 (n\u00e3o autorizado) -&gt; Retorna erro sem reexecutar a tarefa.</li> </ul> Source code in <code>src/celery_worker.py</code> <pre><code>@celery_app.task(\n    bind=True,\n    autoretry_for=(requests.exceptions.RequestException,),\n    retry_backoff=True,\n    max_retries=3,\n)\ndef fetch_data(self, url: str, headers: dict = None):\n    \"\"\"\n    Realiza uma requisi\u00e7\u00e3o GET para uma API externa, com toler\u00e2ncia a falhas.\n\n    Args:\n        url (str): URL da API externa.\n        headers (dict, opcional): Dicion\u00e1rio com cabe\u00e7alhos HTTP, incluindo autentica\u00e7\u00e3o.\n\n    Returns:\n        dict: Resposta JSON da API externa ou mensagem de erro.\n\n    Tratamento de Erros:\n        - Timeout -&gt; Reexecuta a tarefa automaticamente at\u00e9 3 vezes.\n        - HTTP 401 (n\u00e3o autorizado) -&gt; Retorna erro sem reexecutar a tarefa.\n    \"\"\"\n\n    try:\n        response = requests.get(url, headers=headers, timeout=5)\n        UNAUTHORIZED = 401\n        if response.status_code == UNAUTHORIZED:\n            raise Exception('Falha na autentica\u00e7\u00e3o, verifique suas credenciais')\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.Timeout:\n        raise self.retry(exc=Exception('Timeout ao acessar API externa'))\n    except requests.exceptions.HTTPError as err:\n        raise self.retry(exc=err)\n</code></pre>"},{"location":"test_api/","title":"Testando a API","text":"<p>Teste unit\u00e1rio da API</p>"},{"location":"test_api/#src.tests.test_api.test_get_task_status","title":"<code>test_get_task_status(client)</code>","text":"<p>Testa a rota que retorna o status de uma tarefa.</p> Source code in <code>src/tests/test_api.py</code> <pre><code>def test_get_task_status(client):\n    \"\"\"\n    Testa a rota que retorna o status de uma tarefa.\n    \"\"\"\n    response = client.get('/status/test_task_id')\n    assert response.status_code == status.HTTP_200_OK\n    assert 'task_id' in response.json()\n    assert 'status' in response.json()\n</code></pre>"},{"location":"test_api/#src.tests.test_api.test_send_request","title":"<code>test_send_request(url, token, client)</code>","text":"<p>Testa se a API enfileira corretamente uma nova requisi\u00e7\u00e3o.</p> Source code in <code>src/tests/test_api.py</code> <pre><code>def test_send_request(url, token, client):\n    \"\"\"\n    Testa se a API enfileira corretamente uma nova requisi\u00e7\u00e3o.\n    \"\"\"\n    response = client.post(\n        f'/request/?url={url}&amp;token={token}',\n    )\n\n    assert response.status_code == status.HTTP_200_OK\n    assert 'task_id' in response.json()\n    assert response.json()['status'] == 'PENDING'\n</code></pre>"},{"location":"test_celery/","title":"Testando o Celery","text":"<p>Teste unit\u00e1rio do Celery</p> <p>M\u00f3dulo de testes para as tarefas ass\u00edncronas do Celery</p>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_http_error","title":"<code>test_fetch_data_http_error(mock_url_and_invalid_headers)</code>","text":"<p>Testa o tratamento de outros erros HTTP na fun\u00e7\u00e3o fetch_data.</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_http_error(mock_url_and_invalid_headers):\n    \"\"\"\n    Testa o tratamento de outros erros HTTP na fun\u00e7\u00e3o fetch_data.\n    \"\"\"\n    with patch('requests.get') as mock_get:\n        mock_get.side_effect = requests.exceptions.HTTPError('Erro HTTP gen\u00e9rico')\n        with pytest.raises(requests.exceptions.HTTPError, match='Erro HTTP gen\u00e9rico'):\n            fetch_data(\n                mock_url_and_invalid_headers['url'],\n                mock_url_and_invalid_headers['headers'],\n            )\n</code></pre>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_success","title":"<code>test_fetch_data_success(mock_url_and_headers)</code>","text":"<p>Testa o caso de sucesso da fun\u00e7\u00e3o fetch_data.</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_success(mock_url_and_headers):\n    \"\"\"\n    Testa o caso de sucesso da fun\u00e7\u00e3o fetch_data.\n    \"\"\"\n\n    expected_response = {\n        'userId': 1,\n        'id': 1,\n        'title': 'delectus aut autem',\n        'completed': False,\n    }\n\n    with patch('requests.get') as mock_get:\n        mock_get.return_value.status_code = 200\n        mock_get.return_value.json.return_value = expected_response\n\n        response = fetch_data(mock_url_and_headers['url'], mock_url_and_headers['headers'])\n\n        assert response == expected_response\n        mock_get.assert_called_once_with(\n            mock_url_and_headers['url'],\n            headers=mock_url_and_headers['headers'],\n            timeout=5,\n        )\n</code></pre>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_timeout","title":"<code>test_fetch_data_timeout(mock_url_and_headers)</code>","text":"<p>Testa o tratamento de timeout na fun\u00e7\u00e3o fetch_data.</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_timeout(mock_url_and_headers):\n    \"\"\"\n    Testa o tratamento de timeout na fun\u00e7\u00e3o fetch_data.\n    \"\"\"\n    with patch('requests.get') as mock_get:\n        mock_get.side_effect = requests.exceptions.Timeout\n\n        with pytest.raises(Exception, match='Timeout ao acessar API externa'):\n            fetch_data(mock_url_and_headers['url'], mock_url_and_headers['headers'])\n</code></pre>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_unauthorized","title":"<code>test_fetch_data_unauthorized(mock_url_and_invalid_headers)</code>","text":"<p>Testa o tratamento de erro 401 (n\u00e3o autorizado) na fun\u00e7\u00e3o fetch_data.</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_unauthorized(mock_url_and_invalid_headers):\n    \"\"\"\n    Testa o tratamento de erro 401 (n\u00e3o autorizado) na fun\u00e7\u00e3o fetch_data.\n    \"\"\"\n    with patch('requests.get') as mock_get:\n        mock_get.return_value.status_code = 401\n\n        with pytest.raises(Exception, match='Falha na autentica\u00e7\u00e3o, verifique suas credenciais'):\n            fetch_data(\n                mock_url_and_invalid_headers['url'],\n                mock_url_and_invalid_headers['headers'],\n            )\n</code></pre>"},{"location":"test_config/","title":"Configura\u00e7\u00e3o","text":"<p>Configura\u00e7\u00e3o dos testes (fixtures)</p>"},{"location":"test_config/#src.tests.conftest.client","title":"<code>client()</code>","text":"<p>Retorna uma instancia do TestClient</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@pytest.fixture\ndef client():\n    \"\"\"\n    Retorna uma instancia do TestClient\n    \"\"\"\n    return TestClient(app)\n</code></pre>"},{"location":"test_config/#src.tests.conftest.mock_url_and_headers","title":"<code>mock_url_and_headers()</code>","text":"<p>Retorna uma url e um header para teste</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@pytest.fixture\ndef mock_url_and_headers():\n    \"\"\"\n    Retorna uma url e um header para teste\n    \"\"\"\n    token = str(uuid.uuid4())\n    headers = {\"Content-Type\": \"application/json\", \"Authorization\": f\"Bearer {token}\"}\n\n    return {\"url\": \"http://example.com/api\", \"headers\": headers}\n</code></pre>"},{"location":"test_config/#src.tests.conftest.mock_url_and_invalid_headers","title":"<code>mock_url_and_invalid_headers()</code>","text":"<p>Retorna uma url e um header inv\u00e1lidos para teste</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@pytest.fixture\ndef mock_url_and_invalid_headers():\n    \"\"\"\n    Retorna uma url e um header inv\u00e1lidos para teste\n    \"\"\"\n    token = \"invalid_token\"\n    headers = {\"Content-Type\": \"application/json\", \"Authorization\": f\"Bearer {token}\"}\n    return {\"url\": \"http://example.com/api\", \"headers\": headers}\n</code></pre>"},{"location":"test_config/#src.tests.conftest.token","title":"<code>token()</code>","text":"<p>Retorna um token de teste</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@pytest.fixture\ndef token():\n    \"\"\"\n    Retorna um token de teste\n    \"\"\"\n    return str(uuid.uuid4())\n</code></pre>"},{"location":"test_config/#src.tests.conftest.url","title":"<code>url()</code>","text":"<p>Retorna a URL de teste</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@pytest.fixture\ndef url():\n    \"\"\"\n    Retorna a URL de teste\n    \"\"\"\n    return \"http://example.com/api\"\n</code></pre>"}]}
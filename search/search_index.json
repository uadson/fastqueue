{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo (a) documenta\u00e7\u00e3o do FastQueue","text":""},{"location":"#fastapi-celery-rabbitmq-processamento-assincrono-de-apis-externas","title":"FastAPI + Celery + RabbitMQ: Processamento Ass\u00edncrono de APIs Externas","text":"<p>Este projeto demonstra como utilizar FastAPI e Celery com RabbitMQ para realizar chamadas ass\u00edncronas a APIs externas, lidando com falhas como timeout e autentica\u00e7\u00e3o.</p>"},{"location":"#tecnologias-utilizadas","title":"\ud83d\udccc Tecnologias Utilizadas","text":"<ul> <li>FastAPI \u2192 Framework para criar a API.</li> <li>Celery \u2192 Gerenciamento de tarefas ass\u00edncronas.</li> <li>RabbitMQ \u2192 Broker de mensagens.</li> <li>Flower \u2192 Monitoramento das tarefas Celery.</li> <li>Requests \u2192 Biblioteca para chamadas HTTP.</li> </ul>"},{"location":"#como-rodar-o-projeto","title":"\ud83d\ude80 Como Rodar o Projeto","text":""},{"location":"#1-instalar-dependencias","title":"1\ufe0f\u20e3 Instalar Depend\u00eancias","text":"<pre><code>pip install fastapi celery[redis] uvicorn requests flower\n</code></pre>"},{"location":"#2-iniciar-o-rabbitmq","title":"2\ufe0f\u20e3 Iniciar o RabbitMQ","text":"<pre><code>docker run -d --hostname rmq-broker --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management\n</code></pre> <ul> <li>Acessar o painel RabbitMQ em: http://localhost:15672</li> <li>Usu\u00e1rio/Senha padr\u00e3o: guest/guest</li> </ul>"},{"location":"#3-iniciar-o-celery-worker","title":"3\ufe0f\u20e3 Iniciar o Celery Worker","text":"<pre><code>celery -A celery_worker.celery_app worker --loglevel=info\n</code></pre>"},{"location":"#4-rodar-fastapi","title":"4\ufe0f\u20e3 Rodar FastAPI","text":"<pre><code>fastapi dev\n</code></pre>"},{"location":"#monitoramento-com-flower","title":"Monitoramento com Flower","text":"<p>O Flower permite visualizar e monitorar as tarefas do Celery em tempo real. </p>"},{"location":"#1-iniciar-o-flower","title":"1\ufe0f\u20e3 Iniciar o Flower","text":"<pre><code>celery -A celery_worker.celery_app flower --port=5555\n</code></pre>"},{"location":"#2-acessar-o-painel-do-flower","title":"2\ufe0f\u20e3 Acessar o Painel do Flower","text":"<ul> <li>Acessar http://localhost:5555 para visualizar as tarefas em tempo real.</li> <li>L\u00e1 voc\u00ea pode ver: \u2705 Tarefas pendentes, em execu\u00e7\u00e3o e finalizadas. \u2705 Tempo de execu\u00e7\u00e3o e falhas. \u2705 Tentativas de reexecu\u00e7\u00e3o por timeout ou erro.</li> </ul>"},{"location":"#testando-a-api","title":"Testando a API","text":"<ul> <li>Enviar uma requisi\u00e7\u00e3o para a API externa</li> </ul> <pre><code>curl -X 'POST' 'http://127.0.0.1:8000/request/' -H 'Content-Type: application/json' -d '{\"url\": \"https://jsonplaceholder.typicode.com/todos/1\", \"token\": \"meu_token\"}'\n</code></pre> <ul> <li>Resposta esperada:</li> </ul> <pre><code>{\n    \"task_id\": \"b95b9e8f-2f27-49b1-97b5-34aef06b745d\",\n    \"status\": \"PENDING\"\n}\n</code></pre>"},{"location":"#consultar-o-status-da-tarefa","title":"Consultar o Status da Tarefa","text":"<pre><code>curl -X 'GET' 'http://127.0.0.1:8000/status/b95b9e8f-2f27-49b1-97b5-34aef06b745d'\n</code></pre> <ul> <li>Resposta enquanto est\u00e1 processando:</li> </ul> <pre><code>{\n    \"task_id\": \"b95b9e8f-2f27-49b1-97b5-34aef06b745d\",\n    \"status\": \"PENDING\",\n    \"result\": null\n}\n</code></pre> <ul> <li>Resposta ap\u00f3s concluir:</li> </ul> <pre><code>{\n    \"task_id\": \"b95b9e8f-2f27-49b1-97b5-34aef06b745d\",\n    \"status\": \"SUCCESS\",\n    \"result\": {\n        \"userId\": 1,\n        \"id\": 1,\n        \"title\": \"delectus aut autem\",\n        \"completed\": false\n    }\n}\n</code></pre>"},{"location":"#como-funciona","title":"Como funciona?","text":"<pre><code>1 - O FastAPI recebe uma requisi\u00e7\u00e3o para acessar uma API externa.\n2 - A requisi\u00e7\u00e3o \u00e9 enviada para a fila do RabbitMQ usando Celery.\n3 - O Worker Celery recupera a tarefa e faz a requisi\u00e7\u00e3o \u00e0 API externa.\n4 - Se houver timeout ou erro, o Celery tenta novamente automaticamente.\n5 - O usu\u00e1rio pode consultar o status da tarefa via API.\n</code></pre>"},{"location":"api/","title":"API","text":"<p>Requisi\u00e7\u00e3o de envio e recebimento de dados de API externa.</p> <p>API desenvolvida com FastAPI para gerenciar requisi\u00e7\u00f5es ass\u00edncronas utilizando Celery.</p> Rotas dispon\u00edveis <ul> <li>'POST /request/' -&gt; Enfileira uma nova requisi\u00e7\u00e3o para a API externa.</li> <li>'GET' /status/{task_id}' -&gt; Retorna o status da tarefa enfileirada.</li> </ul>"},{"location":"api/#src.main.get_task_status","title":"<code>get_task_status(task_id)</code>","text":"<p>Retorna o status da tarefa enfileirada.</p> <p>Parameters:</p> Name Type Description Default <code>task_id(str)</code> <p>ID da tarefa Celery.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Status da tarefa e resultado, se dispon\u00edvel.</p> Source code in <code>src/main.py</code> <pre><code>@app.get('/status/{task_id}')\ndef get_task_status(task_id: str):\n    \"\"\"\n    Retorna o status da tarefa enfileirada.\n\n    Args:\n        task_id(str): ID da tarefa Celery.\n\n    Returns:\n        dict: Status da tarefa e resultado, se dispon\u00edvel.\n    \"\"\"\n\n    task_result = fetch_data.AsyncResult(task_id)\n    return {\n        'task_id': task_id,\n        'status': task_result.status,\n        'result': task_result.result if task_result.ready() else None,\n    }\n</code></pre>"},{"location":"api/#src.main.send_request","title":"<code>send_request(url, token)</code>","text":"<p>Enfileira uma requisi\u00e7\u00e3o para uma API externa.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL da API externa a ser acessada.</p> required <code>token</code> <code>str</code> <p>Token de autentica\u00e7\u00e3o (Bearer Token).</p> required <code>Returns</code> <p>dict: ID da tarefa Celery e status inicial.</p> required Source code in <code>src/main.py</code> <pre><code>@app.post('/request/')\ndef send_request(url: str, token: str):\n    \"\"\"\n    Enfileira uma requisi\u00e7\u00e3o para uma API externa.\n\n    Args:\n        url (str): URL da API externa a ser acessada.\n        token (str): Token de autentica\u00e7\u00e3o (Bearer Token).\n\n        Returns:\n            dict: ID da tarefa Celery e status inicial.\n    \"\"\"\n\n    headers = {'Authorization': f'Bearer {token}'}\n    task = fetch_data.apply_async(args=[url], kwargs={'headers': headers})\n    return {'task_id': task.id, 'status': task.status}\n</code></pre>"},{"location":"api/#endpoints","title":"Endpoints","text":"<p>-<code>POST /request/</code> - Enfileira uma requisi\u00e7\u00e3o para uma API externa. -<code>GET /status/{task_id}</code> - Obt\u00eam o status da tarefa na fila</p>"},{"location":"celery/","title":"Celery","text":"<p>Distribui\u00e7\u00e3o de tarefas em fila para requisi\u00e7\u00e3o em API externa</p> <p>M\u00f3dulo respons\u00e1vel pelo processamento ass\u00edncrono de tarefas utilizando Celery.</p> <ul> <li>O Celery \u00e9 configurado para utilizar o RabbitMQ como broker.</li> <li>A fun\u00e7\u00e3o 'fetch_data' realiza uma requisi\u00e7\u00e3o HTTP ass\u00edncrona.</li> <li>Implementa tratamento de erros para timeout e autentica\u00e7\u00e3o.</li> </ul>"},{"location":"celery/#src.celery_worker.fetch_data","title":"<code>fetch_data(self, url, headers=None)</code>","text":"<p>Realiza uma requisi\u00e7\u00e3o GET para uma API externa, com toler\u00e2ncia a falhas.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL da API externa.</p> required <code>headers</code> <code>(dict, opcional)</code> <p>Dicion\u00e1rio com cabe\u00e7alhos HTTP, incluindo autentica\u00e7\u00e3o.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Resposta JSON da API externa ou mensagem de erro.</p> Tratamento de Erros <ul> <li>Timeout -&gt; Reexecuta a tarefa automaticamente at\u00e9 3 vezes.</li> <li>HTTP 401 (n\u00e3o autorizado) -&gt; Retorna erro sem reexecutar a tarefa.</li> </ul> Source code in <code>src/celery_worker.py</code> <pre><code>@celery_app.task(\n    bind=True,\n    autoretry_for=(requests.exceptions.RequestException,),\n    retry_backoff=True,\n    max_retries=3,\n)\ndef fetch_data(self, url: str, headers: dict = None):\n    \"\"\"\n    Realiza uma requisi\u00e7\u00e3o GET para uma API externa, com toler\u00e2ncia a falhas.\n\n    Args:\n        url (str): URL da API externa.\n        headers (dict, opcional): Dicion\u00e1rio com cabe\u00e7alhos HTTP, incluindo autentica\u00e7\u00e3o.\n\n    Returns:\n        dict: Resposta JSON da API externa ou mensagem de erro.\n\n    Tratamento de Erros:\n        - Timeout -&gt; Reexecuta a tarefa automaticamente at\u00e9 3 vezes.\n        - HTTP 401 (n\u00e3o autorizado) -&gt; Retorna erro sem reexecutar a tarefa.\n    \"\"\"\n\n    try:\n        response = requests.get(url, headers=headers, timeout=5)\n        response.raise_for_status()  # Lan\u00e7a exce\u00e7\u00e3o para c\u00f3digos de erro HTTP\n        return response.json()\n    except requests.exceptions.Timeout:\n        raise self.retry(exc=Exception(\"Timeout ao acessar API externa\"))\n    except requests.exceptions.HTTPError as err:\n        if response.status_code == requests.codes.unauthorized:\n            raise Exception(\"Falha na autentica\u00e7\u00e3o, verifique suas credenciais\")\n        raise self.retry(exc=err)\n</code></pre>"},{"location":"test_api/","title":"Testando a API","text":"<p>Teste unit\u00e1rio da API</p>"},{"location":"test_api/#src.tests.test_api.test_get_task_status","title":"<code>test_get_task_status(backend_url)</code>","text":"<p>Testa a rota que retorna o status de uma tarefa.</p> Source code in <code>src/tests/test_api.py</code> <pre><code>def test_get_task_status(backend_url):\n    \"\"\"\n    Testa a rota que retorna o status de uma tarefa.\n    \"\"\"\n    with httpx.Client(base_url=backend_url) as client:\n        response = client.get(f\"/status/{RESPONSE['task_id']}\")\n        assert response.status_code == httpx.codes.OK\n        assert \"task_id\" in response.json()\n        assert \"status\" in response.json()\n</code></pre>"},{"location":"test_api/#src.tests.test_api.test_send_request","title":"<code>test_send_request(url, token, backend_url)</code>","text":"<p>Testa se a API enfileira corretamente uma nova requisi\u00e7\u00e3o.</p> Source code in <code>src/tests/test_api.py</code> <pre><code>def test_send_request(url, token, backend_url):\n    \"\"\"\n    Testa se a API enfileira corretamente uma nova requisi\u00e7\u00e3o.\n    \"\"\"\n    with httpx.Client(base_url=backend_url) as client:\n        response = client.post(\n            f\"/request/?url={url}&amp;token={token}\",\n        )\n\n        assert response.status_code == httpx.codes.OK\n        assert \"task_id\" in response.json()\n        RESPONSE[\"task_id\"] = response.json()[\"task_id\"]\n        assert response.json()[\"status\"] == \"PENDING\"\n</code></pre>"},{"location":"test_celery/","title":"Testando o Celery","text":"<p>Teste unit\u00e1rio do Celery</p>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_response","title":"<code>test_fetch_data_response(url)</code>","text":"<p>Testa a fun\u00e7\u00e3o Celery simulando uma API externa.</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_response(url):\n    \"\"\"\n    Testa a fun\u00e7\u00e3o Celery simulando uma API externa.\n    \"\"\"\n    fake_response = {\n        \"userId\": 1,\n        \"id\": 1,\n        \"title\": \"delectus aut autem\",\n        \"completed\": False,\n    }\n\n    with httpx.Client() as client:\n        response = client.get(url)\n        assert response.status_code == httpx.codes.OK\n        result = fetch_data(url)\n        assert result == fake_response\n</code></pre>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_timeout","title":"<code>test_fetch_data_timeout(timeout_url)</code>","text":"<p>Testa o comportamento da fun\u00e7\u00e3o Celery quando ocorre um timeout.</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_timeout(timeout_url):\n    \"\"\"\n    Testa o comportamento da fun\u00e7\u00e3o Celery quando ocorre um timeout.\n    \"\"\"\n    with pytest.raises(Exception, match=\"Timeout ao acessar API externa\"):\n        fetch_data(timeout_url)\n</code></pre>"},{"location":"test_celery/#src.tests.test_celery.test_fetch_data_unauthorized","title":"<code>test_fetch_data_unauthorized(unauthorized_url)</code>","text":"<p>Testa o comportamento da fun\u00e7\u00e3o Celery quando ocorre um erro de autentica\u00e7\u00e3o</p> Source code in <code>src/tests/test_celery.py</code> <pre><code>def test_fetch_data_unauthorized(unauthorized_url):\n    \"\"\"\n    Testa o comportamento da fun\u00e7\u00e3o Celery quando ocorre um\n    erro de autentica\u00e7\u00e3o\n    \"\"\"\n    with pytest.raises(\n        Exception, match=\"Falha na autentica\u00e7\u00e3o, verifique suas credenciais\"\n    ):\n        fetch_data(unauthorized_url)\n</code></pre>"},{"location":"test_config/","title":"Configura\u00e7\u00e3o","text":"<p>Configura\u00e7\u00e3o dos testes (fixtures)</p>"},{"location":"test_config/#src.tests.conftest.backend_url","title":"<code>backend_url()</code>","text":"<p>Retorna a URL do backend</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@fixture\ndef backend_url():\n    \"\"\"\n    Retorna a URL do backend\n    \"\"\"\n    return BACKEND\n</code></pre>"},{"location":"test_config/#src.tests.conftest.timeout_url","title":"<code>timeout_url()</code>","text":"<p>Retorna uma URL com timeout</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@fixture\ndef timeout_url():\n    \"\"\"\n    Retorna uma URL com timeout\n    \"\"\"\n    return TIMEOUT_URL\n</code></pre>"},{"location":"test_config/#src.tests.conftest.token","title":"<code>token()</code>","text":"<p>Retorna um token de teste</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@fixture\ndef token():\n    \"\"\"\n    Retorna um token de teste\n    \"\"\"\n    return str(uuid.uuid4())\n</code></pre>"},{"location":"test_config/#src.tests.conftest.unauthorized_url","title":"<code>unauthorized_url()</code>","text":"<p>Retorna uma URL com status 401</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@fixture\ndef unauthorized_url():\n    \"\"\"\n    Retorna uma URL com status 401\n    \"\"\"\n    return UNAUTHORIZED_URL\n</code></pre>"},{"location":"test_config/#src.tests.conftest.url","title":"<code>url()</code>","text":"<p>Retorna a URL de teste</p> Source code in <code>src/tests/conftest.py</code> <pre><code>@fixture\ndef url():\n    \"\"\"\n    Retorna a URL de teste\n    \"\"\"\n    return URL\n</code></pre>"}]}